/*problem link = "https://www.hackerrank.com/challenges/the-great-xor/problem"
This solution works on the basis of
e.g n = 10 
Now representing 10 in binary 1010
The max val these 4 bits can store is 1111 i.e 15
so 15-10 = 5 values would be our ans

Thanks to aakash_saini for quite the smart solution, which I'll be using.

Computing every a XOR x for 0 < a < x will result in a timeout inside a hackerrank instance. 
A more efficient solution is required and can be obtained by making two observations.

First, the highest number that a XOR x can yield is limited by the highest bit of x. 
Setting any higher bit will net you a number a > x.

Second, all numbers x < n <= highest can be generated by one a XOR x operation.

Let's use x = 9 as an example. 9 has the binary representation of 0000 1001. 
The highest number that could be obtained with a number a < x has the binary representation of 0000 1111, which is 15.

All q = 6 different numbers in 9 < n <= 15 can be represented by one a XOR x operation. If we wanted to obtain 14 (0000 1110),
we find a = 0000 0111 and see that 0000 0111 XOR 0000 1001 = 0000 1110 (14).







*/

---------------------------------------------------CODE-------------------------------------------------
#include <assert.h>
#include <limits.h>
#include <math.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int q;
    scanf("%d\n",&q);
    while(q--)
    {
        long int n;
        scanf("%li\n",&n);
        long int i,count=0,log = 0;
        long int store = n;
        while(n)
        {
            n /= 2;
            count++;
        }
        count = pow(2,count)-1;
        printf("%li\n",count-store);
    }
}
